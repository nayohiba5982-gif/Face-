<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Face & rPPG Data Collector</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f0f2f5; }
    #container { position: relative; width: 640px; height: 480px; margin: 10px auto; border: 5px solid #fff; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: hidden; }
    video, canvas { position: absolute; top: 0; left: 0; transform: scaleX(-1); }
    .controls { margin: 20px; padding: 20px; background: white; display: inline-block; border-radius: 10px; min-width: 300px; }
    button { padding: 12px 30px; font-size: 16px; cursor: pointer; border-radius: 5px; border: none; transition: 0.3s; font-weight: bold; }
    #startBtn { background: #28a745; color: white; }
    #stopBtn { background: #dc3545; color: white; display: none; }
    input { padding: 10px; font-size: 16px; border: 1px solid #ccc; border-radius: 5px; width: 140px; margin: 5px; }
    #status { margin-top: 15px; font-weight: bold; color: #555; }
    
    /* ã‚¿ã‚¤ãƒãƒ¼ã¨ã‚¹ã‚³ã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #display-panel { display: none; margin-bottom: 15px; }
    #timer { font-size: 48px; color: #dc3545; font-weight: bold; font-family: monospace; }
    #score { font-size: 20px; color: #007bff; margin-top: 5px; font-weight: bold; }
  </style>
</head>
<body>
  <h1>rPPG Data Collector</h1>

  <div class="controls">
    <div id="display-panel">
      <div id="timer">00.0s</div>
      <div id="score">æ¨å®šå¿ƒæ‹æ•°: -- BPM</div>
    </div>

    <input type="password" id="passCode" placeholder="Password">
    <input type="text" id="userID" placeholder="User_ID">
    <br>
    <button id="startBtn">è¨ˆæ¸¬é–‹å§‹ (30ç§’)</button>
    <button id="stopBtn">é€ä¿¡ä¸­...</button>
    <div id="status">ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...</div>
  </div>

  <div id="container">
    <video id="input_video"></video>
    <canvas id="output_canvas" width="640px" height="480px"></canvas>
  </div>

  <script>
    const GAS_URL = "https://script.google.com/macros/s/AKfycby0dWkUb06_85_P2TO-RuocPjgYSsW3KtJ7UXKzFnrcSs6fmHjOxVhWzHfWz2x8PaRD/exec";
    const SECRET_PASS = "team123"; 

    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusElement = document.getElementById('status');
    const timerElement = document.getElementById('timer');
    const scoreElement = document.getElementById('score');
    const displayPanel = document.getElementById('display-panel');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const userIDInput = document.getElementById('userID');
    const passInput = document.getElementById('passCode');

    let isRecording = false;
    let recordedData = [];
    let startTime = 0;
    let timerId = null;

    const ROI_LANDMARKS = {
      forehead: [10, 151, 9],
      rightCheek: [117, 118, 101],
      leftCheek: [347, 348, 330]
    };

    function onResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        if (!isRecording) statusElement.innerText = "æº–å‚™å®Œäº†ï¼šæ­£é¢ã‚’å‘ã„ã¦ãã ã•ã„";

        const foreheadColor = getAverageColorOfPoints(landmarks, ROI_LANDMARKS.forehead);
        const rCheekColor = getAverageColorOfPoints(landmarks, ROI_LANDMARKS.rightCheek);
        const lCheekColor = getAverageColorOfPoints(landmarks, ROI_LANDMARKS.leftCheek);

        drawGuide(landmarks);

        if (isRecording) {
          recordedData.push({
            time: Date.now(),
            landmarks: landmarks.slice(0, 5).map(l => ({x: l.x, y: l.y})), // è»½é‡åŒ–ã®ãŸã‚åº§æ¨™æ•°ã‚’å‰Šæ¸›
            rppg: { forehead: foreheadColor, right: rCheekColor, left: lCheekColor }
          });
          updateLiveBPM();
        }
      } else {
        statusElement.innerText = "é¡”ãŒèªè­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“";
      }
      canvasCtx.restore();
    }

    // ç°¡æ˜“çš„ãªãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ BPMè¡¨ç¤º (æœ€æ–°3ç§’ã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç®—å‡º)
    function updateLiveBPM() {
      if (recordedData.length < 60) return;
      const recent = recordedData.slice(-90);
      const gs = recent.map(d => (d.rppg.forehead.g + d.rppg.right.g + d.rppg.left.g)/3);
      const mean = gs.reduce((a,b) => a+b) / gs.length;
      let peaks = 0;
      for(let i=1; i<gs.length-1; i++) {
        if(gs[i] > mean && gs[i] > gs[i-1] && gs[i] > gs[i+1]) peaks++;
      }
      const dur = (recent[recent.length-1].time - recent[0].time) / 1000;
      const bpm = Math.round((peaks / dur) * 60);
      if(bpm > 40 && bpm < 120) scoreElement.innerText = `æ¨å®šå¿ƒæ‹æ•°: ${bpm} BPM`;
    }

    function getAverageColorOfPoints(landmarks, indices) {
      let r = 0, g = 0, b = 0;
      indices.forEach(idx => {
        const point = landmarks[idx];
        const x = Math.floor((1 - point.x) * canvasElement.width);
        const y = Math.floor(point.y * canvasElement.height);
        const imageData = canvasCtx.getImageData(x, y, 1, 1).data;
        r += imageData[0]; g += imageData[1]; b += imageData[2];
      });
      return { r: Math.round(r/indices.length), g: Math.round(g/indices.length), b: Math.round(b/indices.length) };
    }

    function drawGuide(landmarks) {
      canvasCtx.fillStyle = "#00ff00";
      [...ROI_LANDMARKS.forehead, ...ROI_LANDMARKS.rightCheek, ...ROI_LANDMARKS.leftCheek].forEach(idx => {
        const p = landmarks[idx];
        canvasCtx.beginPath();
        canvasCtx.arc((1 - p.x) * canvasElement.width, p.y * canvasElement.height, 3, 0, 2*Math.PI);
        canvasCtx.fill();
      });
    }

    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: false, minDetectionConfidence: 0.5, minFacePresenceConfidence: 0.5 });
    faceMesh.onResults(onResults);

    const camera = new Camera(videoElement, {
      onFrame: async () => { await faceMesh.send({image: videoElement}); },
      width: 640, height: 480
    });
    camera.start();

    startBtn.onclick = () => {
      if(passInput.value !== SECRET_PASS) { alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™"); return; }
      if(!userIDInput.value) { alert("IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
      
      isRecording = true;
      startTime = Date.now();
      recordedData = [];
      
      startBtn.style.display = "none";
      displayPanel.style.display = "block";
      statusElement.innerText = "â— è¨ˆæ¸¬ä¸­... å‹•ã‹ãªã„ã§ãã ã•ã„";

      // ç‹¬ç«‹ã‚¿ã‚¤ãƒãƒ¼èµ·å‹• (100mså‘¨æœŸ)
      timerId = setInterval(() => {
        const elapsed = (Date.now() - startTime) / 1000;
        timerElement.innerText = elapsed.toFixed(1) + "s";
        
        // 30ç§’ã§è‡ªå‹•çµ‚äº†
        if (elapsed >= 30) {
          stopAndSend();
        }
      }, 100);
    };

    async function stopAndSend() {
      isRecording = false;
      clearInterval(timerId);
      
      startBtn.style.display = "none";
      stopBtn.style.display = "inline-block";
      stopBtn.disabled = true;
      statusElement.innerText = "ğŸš€ ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ä¸­... æ•°ç§’ã‹ã‹ã‚Šã¾ã™";

      try {
        await fetch(GAS_URL, {
          method: "POST",
          mode: "no-cors",
          body: JSON.stringify({ userID: userIDInput.value, points: recordedData })
        });
        alert("é€ä¿¡å®Œäº†ï¼ãŠç–²ã‚Œæ§˜ã§ã—ãŸã€‚");
        location.reload(); 
      } catch (e) {
        alert("é€ä¿¡å¤±æ•—ã€‚ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
        stopBtn.disabled = false;
      }
    }
  </script>
</body>
</html>
